{"ast":null,"code":"function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport { all, takeEvery, put, call } from 'redux-saga/effects';\nimport actions from './actions';\nimport omit from 'lodash/omit';\nimport fakeData from './fakeData';\nimport { rsf, db } from '@iso/lib/firebase/firebase';\nimport { convertCollectionsSnapshotToMap, deleteDocuments, addCollectionAndDocuments } from '@iso/lib/firebase/firebase.util';\nconst fakeDataList = new fakeData(5).getAll();\n/**\n * DOC: https://redux-saga-firebase.js.org/reference/dev/firestore\n */\n\nconst COLLECTION_NAME = 'articles'; // change your collection\n\nconst ORDER_BY = 'id';\nconst ORDER = 'desc';\n\nfunction* loadFromFirestore() {\n  try {\n    const collectionRef = db.collection(COLLECTION_NAME).where('deleted_at', '==', null).orderBy(ORDER_BY, ORDER);\n    const snapshots = yield call(rsf.firestore.getCollection, collectionRef);\n    let data = yield call(convertCollectionsSnapshotToMap, snapshots);\n    yield put(actions.loadFromFireStoreSuccess(data));\n  } catch (error) {\n    console.log(error);\n    yield put(actions.loadFromFireStoreError(error));\n  }\n}\n\nfunction* storeIntoFirestore({\n  payload\n}) {\n  const {\n    data,\n    actionName\n  } = payload;\n\n  try {\n    switch (actionName) {\n      case 'delete':\n        yield call(rsf.firestore.setDocument, `${COLLECTION_NAME}/${data.key}`, {\n          deleted_at: new Date().getTime()\n        });\n        break;\n\n      case 'update':\n        yield call(rsf.firestore.setDocument, `${COLLECTION_NAME}/${data.key}`, _objectSpread({}, omit(data, ['key'])));\n        break;\n\n      default:\n        yield call(rsf.firestore.addDocument, COLLECTION_NAME, data);\n        break;\n    }\n\n    yield put({\n      type: actions.LOAD_FROM_FIRESTORE\n    });\n  } catch (error) {\n    console.log(error);\n    yield put(actions.saveIntoFireStoreError(error));\n  }\n}\n\nfunction* resetFireStoreDocuments() {\n  try {\n    yield call(deleteDocuments, COLLECTION_NAME);\n    yield call(addCollectionAndDocuments, COLLECTION_NAME, fakeDataList);\n    yield put({\n      type: actions.LOAD_FROM_FIRESTORE\n    });\n  } catch (error) {\n    console.log(error);\n  }\n}\n\nexport default function* rootSaga() {\n  yield all([takeEvery(actions.LOAD_FROM_FIRESTORE, loadFromFirestore), takeEvery(actions.SAVE_INTO_FIRESTORE, storeIntoFirestore), takeEvery(actions.RESET_FIRESTORE_DOCUMENTS, resetFireStoreDocuments)]);\n}","map":null,"metadata":{},"sourceType":"module"}