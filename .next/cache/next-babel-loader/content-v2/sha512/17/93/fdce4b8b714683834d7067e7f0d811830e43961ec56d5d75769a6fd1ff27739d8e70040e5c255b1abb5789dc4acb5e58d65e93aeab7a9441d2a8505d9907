{"ast":null,"code":"function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport { db } from './firebase';\nexport function convertCollectionsSnapshotToMap(snapshots) {\n  return snapshots.docs.reduce((accumulator, collection) => {\n    accumulator[collection.id] = collection.data();\n    return accumulator;\n  }, {});\n}\nexport async function getNewDocRef(collectionName) {\n  return await db.collection(collectionName).doc();\n}\nexport async function addDocument(collectionName, documentData) {\n  return await db.collection(collectionName).add(documentData).then(docRef => docRef.id);\n}\nexport async function setDocument(collectionName, docRef, documentData) {\n  return await db.collection(collectionName).doc(docRef).set(documentData);\n}\nexport async function getDocuments(collectionName) {\n  return await db.collection(collectionName).get().then(querySnapshot => querySnapshot.docs.map(doc => _objectSpread({\n    id: doc.id\n  }, doc.data())));\n}\nexport async function getDocumentsByQuery(collectionName, query) {\n  console.log(...query, collectionName, 'test');\n  return await db.collection(collectionName).where(...query).get().then(querySnapshot => querySnapshot.docs.map(doc => _objectSpread({\n    id: doc.id\n  }, doc.data())));\n}\nexport async function deleteDocuments(collectionName) {\n  const collectionRef = db.collection(collectionName);\n  var batch = db.batch();\n  await collectionRef.get().then(querySnapshot => querySnapshot.docs.map(doc => batch.delete(collectionRef.doc(doc.id))));\n  return await batch.commit().then(() => {\n    console.log('Batch Deletion successfully committed!');\n  });\n}\nexport const addCollectionAndDocuments = async (collectionKey, objectsToAdd) => {\n  const collectionRef = db.collection(collectionKey);\n  const batch = db.batch();\n  objectsToAdd.forEach(obj => {\n    const newDocRef = collectionRef.doc();\n    batch.set(newDocRef, obj);\n  });\n  return await batch.commit().then(() => {\n    console.log('Batch Addition successfully committed!');\n  });\n}; // const { title, items } = doc.data();\n//     return {\n//       routeName: encodeURI(title.toLowerCase()),\n//       id: doc.id,\n//       title,\n//       items,\n//     };\n//   });\n//   console.log(transformedCollection);\n//   return transformedCollection.reduce((accumulator, collection) => {\n//     accumulator[collection.title.toLowerCase()] = collection;\n//     return accumulator;\n//   }, {});","map":null,"metadata":{},"sourceType":"module"}